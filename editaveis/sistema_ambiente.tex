Este capítulo descreve partes do sistema como um todo, abrangendo ferramentas de controle de estrutura, módulos de interface, hardwares envolvidos e afins. Serão apresentados os desenvolvimentos das partes de:

\begin{itemize}
	\item \nameref{software}
	\begin{itemize}
		\item Controle de infraestrutura
		\item Interface de controle
		\item Visualização de dados
	\end{itemize}
	\item \nameref{eletronica}
	\begin{itemize}
		\item Aquisição de dados
		\begin{itemize}
			\item Circuito do sistema
			\item Interface de aquisição e disponibilização dos dados (microcontrolador)
		\end{itemize}
	\end{itemize}
	\item \nameref{automotiva}
	\begin{itemize}
		\item Estrutura do produto e seus esforços
	\end{itemize}
	\item \nameref{energia}
	\begin{itemize}
		\item Acoplamento do alternador
		\item Cálculos de eficiência
	\end{itemize}
\end{itemize}


\chapter{Software}
\label{software}

\section{Puppet} % (fold)
\label{sec:puppet}

Para agilizar e evitar os problema com compatibilidades e erros de versões de bibliotecas e outros ativos, foi utilizado a ferramenta \href{http://puppetlabs.com}{Puppet} para auxiliar com este processo administrativo de desenvolvimento do sistema. O Puppet está sendo usado como ferramanta para gerenciamento de configuração do ambiente de desenvolvimento do projeto Bike-X.

\subsection{O que é o Puppet} % (fold)
\label{sub:o_que_o_puppet}

\gls{puppet} é uma ferramenta de gerenciamento de configuração feita em \gls{ruby} que permite que seja definido o estado da infraestrutura de TI (Tecnologia da Informação), com isso, a configuração pode ser replicada em qualquer ambiente, levando em consideração as restrições de implementação da definição do ambiente. Para gerenciamento de alguns servidores ou maquinas, sejam elas físicas ou virtuais, o Puppet automatiza as tarefas administrativas do sistema que normalmente são feitas manualmente, liberando tempo e espaço mental dos administradores de sistemas para trabalhar nos projetos que proporcionam maior valor ao negócio.

O Puppet possui uma sintaxe própria, o mesmo utiliza uma linguagem declarativa, ao invés de uma linguagem imperativa, que é utilizada pela maioria das ferramentas similares, como por exemplo o \gls{chef}. A linguagem imperativa é um conceito baseado em estados, definidos por variáveis, e ações que são manipuladoras de estado, procedimentos. Pelo fato de permitir o uso de procedimentos como estruturação, também é conhecido como procedural. A linguagem declarativa, ao contrário da linguagem imperativa que informa ao computador "como" as instruções devem ser executadas, preocupa-se em apenas dizer ao computador "o que" precisa ser feito, cabendo ao computador decidir qual a melhor solução para essa solicitação.
 

\subsection{Integrando o Puppet ao projeto} % (fold)
\label{sub:integrando_o_puppet_ao_projeto}

Para a utilização do Puppet dentro do projeto foi desenvolvido um módulo puppet específico, chamado \href{https://github.com/start-x/startx-src/tree/master/puppet}{bike-x}. Nesse módulo é definido nome e versão de pacotes a serem instalados, é definido links simbólicos, criação de arquivos de configuração para o \gls{rift}. O módulo em questão foi testado e homologado para algumas distribuições do sistema operacional Linux:

\begin{itemize}
\item Ubuntu 13.10
\item Ubuntu 14.04
\item Mint 17
\item Debian Wheezy
\item Debian Sid
\end{itemize}

Todas as distribuições apresentadas são "Debian like" e o módulo está totalmente modularizado para a adição de qualquer nova distribuição necessária, entretanto, as apresentadas acima atende 100\% a equipe de desenvolvimento do projeto. A lista de pacotes Debian necessários para o projeto estão listados a seguir:

\begin{itemize}
\item python2.7
\item python2.7-dev
\item python-serial
\item doxygen
\item graphviz
\item dots
\item binutils-msp430
\item gcc-msp430
\item msp430-libc
\item msp430mcu
\item mspdebug
\item libxext-dev
\item mesa-common-dev
\item freeglut3-dev
\item libxinerama-dev
\item libxrandr-dev
\item libxxf86vm-dev
\item swig
\end{itemize}

A seguir lista de pacotes Python utilizados:

\begin{itemize}
\item pyserial
\item mock
\end{itemize}

Após a execução do módulo Puppet desenvolvido, todos os pacotes listados acima estarão instalados no sistema. Para facilitar a execução do módulo Puppet para todos da equipe, foi desenvolvido um Shell script chamado "setup\_development\_environment.sh" onde é instalado o Puppet em si e os módulos que são dependência, que são o \textit{pip} e \textit{stdlib}, e executado o módulo Puppet bike-x.


\section{Interface Python} % (fold)
\label{sec:interface_python}

A interface \gls{python} sim1plifica a comunicação com o microcontrolador, possibilitando o \textit{parse} entre o modulo principal (BikeX \ref{sec:sistema_bikex}) e o \gls{msp}.

A interface faz de uso da biblioteca \href{http://pyserial.sourceforge.net/pyserial.html}{Pyserial} para manter a comunicação com o microcontrolador. Devido as inúmeras possibilidades de conflitos existentes de caracteres e velocidade de comunicação existentes na comunicação \gls{rs232}, os desenvolvedores da \textit{Pyserial} construíram a classe \textit{serial.tools.miniterm} na qual simula um terminal de comunicação como exemplo de uso da biblioteca. O grupo construiu então uma classe que herda da \textit{serial.tools.miniterm}, simplificando assim a comunicação e incrementando a estabilidade de comunicação. Esta ação gera a dependência de que a versão da \textit{Pyserial} necessita ser 2.7 ou superior.

\subsection{Visão do BikeX} % (fold)
\label{sub:vis_o_do_bikex}

Do ponto de vista do BikeX a aplicação Python estará rodando sempre em \textit{background} esperando um sinal para a realização de alguma tarefa. A depender do sinal recebido, será realizado uma leitura do estado dos sensores ou o envio do valor de posicionamento do freio.

% Por ser um programa assíncrono, a aplicação passará grande parte do tempo ociosa.
A tomada de uso de sinais para acordar o processo possibilita que o mesmo se mantenha em descanso durante todo o período em que não há requisição de dados. Como resultado do ponto de vista da arquitetura que suportado software, não há uma sobrecarga de processamento, evitando o \textit{overhead} de requisições desnecessárias e possibilitando assim que o processamento possa ficar focado onde realmente há uma grande demanda de CPU e GPU, que é a interface gráfica da aplicação.

No trecho de código a seguir (\ref{trecho_main_py}) é possível observar a rotina principal da aplicação \textit{Python} populando o objeto do MSP430 com alguns dispositivos e definindo os métodos a serem chamados na ocorrência dos sinais já pré-definidos. Em seguida o programa entra no já referido \textit{loop}, permanecendo nele ate receber um sinal que requisite o termino do processo.

\begin{lstlisting}[language=Python,caption={Trecho da rotina principal do script Python},label=trecho_main_py]
def main():
    pid_bikex = sys.argv[1:2]
    msp430.curb = sensor.Break(msp430.serial,0)
    msp430.velocity = sensor.Velocity(msp430.serial,0)
    msp430.passives = sensor.Passives(msp430.serial,0)


    signal(SIG1, write_file)
    signal(SIG3, read_file)
    signal(SIGINT, safe_quit)
    signal(SIGQUIT, safe_quit)
    signal(SIGABRT, safe_quit)
    while True:
        sleep(0.01)

\end{lstlisting}


\subsection{Visão do MSP430} % (fold)
\label{sub:vis_o_do_msp430}

Do ponto de vista do MSP430 a aplicação Python estará sempre em comunicação ativa com o MSP430, já que a porta serial será aberta assim que o sistema for iniciado e só fechará quando programa vier a fechar.

Como apresentado no código \ref{trecho_main_py}, a aplicação Python estará sempre a espera de um sinal para entrar em contato com o MSP430. Para que ocorra a interação, é enviado um comando especifico ao MSP430 sobre qual dispositivo desejamos ter informação. No código \ref{trecho_device_py} podemos observar a declaração de algumas classes de dispositivos passivos na estrutura física do projeto, como o freio. Todos os dispositivos herdam de uma classe primaria que tem declarada uma sequencia básica de leitura-escrita de comandos no MSP430.


\begin{lstlisting}[language=Python,caption={Declaração de classes fundamentais no script Python},label=trecho_device_py]
class Passive(Device):
    """docstring for Active"""
    def __init__(self, terminal):
        super(Passive, self).__init__(terminal)
        self.data = self.serial.readline()
        self.data = self.data.split('\n')[0]

    def read_data(self, command):
        """ Send some data to device """
        self.serial.write(str(command))
        self.data = self.serial.readline()
        self.data = self.data.split('\n')[0]
        return self.data

    def write_data(self, command, data):
        return None

class Velocity(Passive):
    """docstring for Velocity"""
    def __init__(self,terminal, arg=VELOCITY_MSP):
        super(Velocity, self).__init__(terminal)
        self.arg = arg
        
    def read_data(self):
        return super(Velocity, self).read_data(self.arg)

class Passives(Passive):
    """docstring for Passives"""
    def __init__(self,terminal, arg=ALL_VALUES):
        super(Passives, self).__init__(terminal)
        self.arg = arg
        
    def read_data(self):
        return super(Passives, self).read_data(self.arg)
\end{lstlisting}

Definido uma interface padrão de leitura-escrita nos dispositivos, é então instanciado no objeto \textbf{MSP} a os dispositivos desejados para que a rotina principal possa interagir com os dispositivos. Para uma mair comodidade e melhor visualização da escrita do código, foram definidos os métodos \textit{\_\_getitem\_\_} e \textit{\_\_setitem\_\_} da classe \textbf{MSP}, conforme apresentado a seguir:

\begin{lstlisting}[language=Python,caption={Declaração dos métodos de leitura e escrita de item},label=trecho_item_py]
    def __getitem__(self,key):
        """ Return the value of a item """
        try:
            return getattr(self,key).read_data()
        except Exception, e:
            raise e

    def __setitem__(self,key,item):
        """ Set a value of a item """
        getattr(self,key).write_data(str(item))
\end{lstlisting}

As rotinas implementadas no trecho do código \ref{trecho_item_py} permitem a leitura e o envio de algum valor, respectivamente, de um possível atributo \textit{foo} - meramente ilustrativo de exemplo - da seguinte forma:

\begin{lstlisting}[frame=none,numbers=none]  % Start your code-block

>>> msp430.foo = sensor.Passives(msp430.serial,0)
>>> print msp430['foo']
>>> 33
>>> """Sending some value"""
>>> msp430['foo'] = 30
\end{lstlisting}

	Obviamente que, como visto no código \ref{trecho_device_py}, o método de escrita de objetos passivos se resume a retornar um objeto nulo, não interagindo assim com o MSP430. Porém, esta solução permite que, se houvesse o interesse em fazer de uso de algum dispositivo no MSP430 que pudesse assumir estados e retornar valores, a interação com ele seria a mais transparente possível. Um possível exemplo seria uma segunda porta de comunicação, seja ela UART ou algum outro protocolo de comunicação como $CAN$ ou $I^2C$. Da mesma forma que poderíamos enviar uma \textit{string} pela UART para ser equalizada na outra porta, poderíamos receber uma mensagem nova pela mesma.

% Os códigos na integra podem ser observados nas sessões \ref{main_py}, \ref{device_py} e \ref{msp430_py}  nos anexos.
